
### get_services_from_repo
```json
{"model": "gpt-4", "messages": [{"role": "system", "content": "\nYou will be provided a GitHub organization name, a repository name, and the directory hierarchy for that repository (starting from the root of the repository). Your task is to create a short, human-readable name and a description for any public HTTP services hosted in this repository. It's likely that there is exactly one service in the repository, however there may be more than one in the case of a monorepo hosting multiple applications, and there may be none in the case of a repository hosting only shared library code, developer tools, configuration, etc.\n\nThe directory hierarchy will be delimited by three exclamation points, and formatted this way:\n\n- <directory name>\n    - <directory name>\n        - <file name>\n        - <file name>\n    - <directory name>\n        - <file name>\n    - ...\n\nThe service name(s) will be used in a high-level system architecture diagram. Go through the hierarchy a few times before you make your decision, each time refining your understanding of the repository.\n\nOutput your answer as a JSON array of objects, with each object containing the following keys:\n\n- \"service_name\": the name that you created for the service\n- \"service_description\": the description that you wrote for the service\n- \"service_root\": The path to the directory in the provided hierarchy that can be considered the root directory of the service.\n\nYour full response should be JSON-parseable, so don't respond with something that can't be parsed by a JSON parser.\n"}, {"role": "user", "content": "\n        GitHub organization: eave-fyi\n\n        Repository: eave-monorepo\n\n        Directory Hierarchy:\n        !!!\n        - apps/slack\n- apps/slack/eave\n    - apps/slack/eave/slack\n        - apps/slack/eave/slack/requests\n            - apps/slack/eave/slack/requests/warmup.py\n            - apps/slack/eave/slack/requests/event_processor.py\n            - apps/slack/eave/slack/requests/__init__.py\n            - apps/slack/eave/slack/requests/event_callback.py\n        - apps/slack/eave/slack/brain\n            - apps/slack/eave/slack/brain/base.py\n            - apps/slack/eave/slack/brain/intent_processing.py\n            - apps/slack/eave/slack/brain/communication.py\n            - apps/slack/eave/slack/brain/message_prompts.py\n            - apps/slack/eave/slack/brain/subscription_management.py\n            - apps/slack/eave/slack/brain/document_management.py\n            - apps/slack/eave/slack/brain/context_building.py\n            - apps/slack/eave/slack/brain/document_metadata.py\n            - apps/slack/eave/slack/brain/core.py\n        - apps/slack/eave/slack/slack_app.py\n        - apps/slack/eave/slack/__init__.py\n        - apps/slack/eave/slack/event_handlers.py\n        - apps/slack/eave/slack/slack_models.py\n        - apps/slack/eave/slack/app.py\n        - apps/slack/eave/slack/config.py\n- apps/slack/bin\n- apps/slack/socketmode.py\n        !!!\n"}], "temperature": 0, "stop": ["STOP_SEQUENCE"]}
```


### get_dependencies
```json
{"model": "gpt-4", "messages": [{"role": "system", "content": "\n            You will be given a GitHub organization name, a repository name, and some code from that repository. The code will be delimited by three exclamation marks. Your task is to find the APIs and services that the code depends on, which will then be used to create a high-level system architecture diagram.\n\n            To perform this task, follow these steps:\n\n            1. Find references to well-known, common third-party services in the code. For example, there may be references to Google Cloud, AWS, Redis, Postgres, Slack API, SendGrid.\n\n            2. Find references to internal services. For example: Analytics, Core API, Authentication, Users API, GraphQL, Logging, Storage, Database.\n\n            3. Once you've gone through the code and have a better understanding of its purpose and context, go through it a few more times and adjust your list if necessary based on what you've learned.\n\n            4. For each service, either use one of the provided known service names if it makes sense to do so, otherwise create a short, human-readable name for the service.\n\n            5. Write a 1-paragraph explanation of what the service does and how it fits into the system architecture.\n\n            The code might not have any references to other systems. If you don't think there are any, don't force it.\n\n\nOutput your answer as a JSON array of objects, with each object containing the following keys:\n\n- \"service_name\": the name that you created for the service\n- \"service_description\": the description that you wrote for the service\n\nYour full response should be JSON-parseable, so don't respond with something that can't be parsed by a JSON parser.\n\n"}, {"role": "user", "content": "\n            GitHub organization: eave-fyi\n\n            Repository: eave-monorepo\n\n            Known service names: Slack API, Eave Core API, Cache, Logging, Google Cloud Tasks, Analytics, Configuration, OpenAI API, Eave Logging, Eave Link Handler, Eave App Configuration, Eave Stdlib\n\n             Code:\n            !!!\n            from eave.stdlib.core_api.models.subscriptions import SubscriptionInfo\nfrom . import message_prompts\n\n\nfrom eave.stdlib.logging import eaveLogger\nfrom .intent_processing import IntentProcessingMixin\n\n\nclass Brain(IntentProcessingMixin):\n    async def process_message(self) -> None:\n        eaveLogger.debug(\"Brain.process_message\", self.eave_ctx)\n\n        await self.load_data()\n\n        subscription_response = await self.get_subscription()\n        if subscription_response.subscription:\n            self.subscriptions.append(\n                SubscriptionInfo(\n                    subscription=subscription_response.subscription,\n                    document_reference=subscription_response.document_reference,\n                )\n            )\n\n        i_am_mentioned = await self.message.check_eave_is_mentioned()\n        if i_am_mentioned is True:\n            \"\"\"\n            Eave is mentioned in this message.\n            1. Acknowledge receipt of the message.\n            1. If she's being asked for thread information, handle that and stop processing.\n            1. Otherwise, send a preliminary response and continue processing.\n            \"\"\"\n            await self.acknowledge_receipt()\n\n            self.message_action = await message_prompts.message_action(context=self.message_context)\n\n            self.log_event(\n                event_name=\"eave_mentioned\",\n                event_description=\"Eave was mentioned in Slack\",\n                opaque_params={\n                    \"action\": self.message_action,\n                },\n            )\n\n        else:\n            \"\"\"\n            Eave is not mentioned in this message.\n            1. Lookup an existing subscription for this source.\n            1. If she is not subscribed, then ignore the message and stop processing.\n            1. Otherwise, continue processing.\n            \"\"\"\n            if len(self.subscriptions) == 0:\n                eaveLogger.debug(\"Eave is not subscribed to this thread; ignoring.\", self.eave_ctx)\n                return\n\n            self.message_action = message_prompts.MessageAction.REFINE_DOCUMENTATION\n\n        self.log_event(\n            event_name=\"slack_eave_action\",\n            event_description=\"Eave is taking an action based on a Slack message\",\n            opaque_params={\n                \"action\": self.message_action,\n            },\n        )\n\n        await self.handle_action(message_action=self.message_action)\n\n    async def process_shortcut_event(self) -> None:\n        await self.acknowledge_receipt()\n\n        # source = eave_models.SubscriptionSource(\n        #     event=eave_models.SubscriptionSourceEvent.slack_message,\n        #     id=message.subscription_id,\n        # )\n\n        # response = await eave_models.client.get_or_create_subscription(source=source)\n        # manager = DocumentManager(message=message, subscription=response.subscription)\n        # await manager.process_message()\n\n    async def load_data(self) -> None:\n        user_profile = await self.message.get_user_profile()\n        self.user_profile = user_profile\n\n        expanded_text = await self.message.get_expanded_text()\n        if expanded_text is None:\n            eaveLogger.warning(\n                \"slack message expanded_text is unexpectedly None\",\n                self.eave_ctx,\n                {\"message_text\": self.message.text},\n            )\n\n            # FIXME: Brain should allow None expanded_text so it can retry.\n            expanded_text = \"\"\n\n        self.expanded_text = expanded_text\n\n        await self.build_message_context()\n\n            !!!\n"}], "temperature": 0, "stop": ["STOP_SEQUENCE"]}
```

